using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CoffeeCard.Generators.Builder;

[Generator]
public class BuilderGenerator : IIncrementalGenerator
{
    private const string BuilderForAttribute = "CoffeeCard.Tests.Common.BuilderForAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var namedTypeSymbols = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: BuilderForAttribute,
                predicate: IsSyntaxTargetForGeneration,
                transform: GetSemanticTargetForGeneration
            )
            .Where(t => t is not null)
            .Collect();

        context.RegisterSourceOutput(
            namedTypeSymbols,
            (productionContext, array) =>
            {
                foreach (var typeSymbol in array)
                {
                    //Retrieve the entity it is a builder for
                    var entity = (INamedTypeSymbol)
                        typeSymbol
                            .GetAttributes()
                            .Single(attr => attr.AttributeClass.Name == "BuilderForAttribute")
                            .ConstructorArguments[0]
                            .Value;
                    var code = GenerateBuilderCode(typeSymbol, entity);
                    var sourceText = SourceText.From(code, Encoding.UTF8);
                    productionContext.AddSource($"{typeSymbol.Name}.g.cs", sourceText);
                }
            }
        );
    }

    private static bool IsSyntaxTargetForGeneration(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken
    )
    {
        return syntaxNode is ClassDeclarationSyntax classDeclaration;
    }

    private static INamedTypeSymbol GetSemanticTargetForGeneration(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken
    )
    {
        return (INamedTypeSymbol)context.TargetSymbol;
    }

    private string GenerateBuilderCode(INamedTypeSymbol typeSymbol, ITypeSymbol entity)
    {
        var codeBuilder = new StringBuilder();

        codeBuilder.AppendLine("// <auto-generated/>");
        codeBuilder.AppendLine("#nullable enable");
        codeBuilder.AppendLine("using System;");
        codeBuilder.AppendLine("using Bogus;");
        codeBuilder.AppendLine($"using {entity.ContainingNamespace};");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine($"namespace {typeSymbol.ContainingNamespace};");
        codeBuilder.AppendLine();

        codeBuilder.AppendLine(
            $"public partial class {typeSymbol.Name} : BaseBuilder<{entity.Name}>, IBuilder<{typeSymbol.Name}>"
        );
        codeBuilder.AppendLine("{");

        // Retrieve all properties of the given entity
        var properties = entity
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.Kind == SymbolKind.Property);

        var entityNameChar = entity.Name.ToLowerInvariant()[0];
        // Generate builder methods for all properties
        var configBuilder = new StringBuilder();
        foreach (var property in properties)
        {
            if (property.Name.Contains("Id"))
            {
                configBuilder.AppendLine(
                    $"            .Ignore({entity.Name} => {entity.Name}.{property.Name})"
                );
            }
            AddWithPropertyValueToCodeBuilder(
                codeBuilder: codeBuilder,
                typeSymbol: typeSymbol,
                property: property,
                entityNameChar: entityNameChar
            );

            AddWithPropertySetterToCodeBuilder(
                codeBuilder: codeBuilder,
                typeSymbol: typeSymbol,
                property: property,
                entityNameChar: entityNameChar
            );
        }
        AddPrivateConstructorToCodeBuilder(codeBuilder, typeSymbol, configBuilder);

        // End class
        codeBuilder.AppendLine("}");

        return codeBuilder.ToString();
    }

    /// <summary>
    /// Generates a private constructor for the builder, to ensure the simple, or typical methods are used for instantiation
    /// </summary>
    /// <param name="codeBuilder"></param>
    /// <param name="typeSymbol"></param>
    /// <param name="configBuilder"></param>
    private void AddPrivateConstructorToCodeBuilder(
        StringBuilder codeBuilder,
        ITypeSymbol typeSymbol,
        StringBuilder configBuilder
    )
    {
        codeBuilder.AppendLine($"    private {typeSymbol.Name} ()");
        codeBuilder.AppendLine("    {");
        codeBuilder.Append("        Faker");
        codeBuilder.Append($"{configBuilder};");
        codeBuilder.AppendLine("    }");
    }

    private void AddWithPropertyValueToCodeBuilder(
        StringBuilder codeBuilder,
        ITypeSymbol typeSymbol,
        IPropertySymbol property,
        char entityNameChar
    )
    {
        MarkObsoleteAsObsolete(codeBuilder, property);

        codeBuilder.AppendLine(
            $"    public {typeSymbol.Name} With{property.Name}({property.Type} {property.Name}Value)"
        );
        codeBuilder.AppendLine("    {");

        codeBuilder.AppendLine(
            $"        Faker.RuleFor({entityNameChar} => {entityNameChar}.{property.Name}, {property.Name}Value);"
        );
        codeBuilder.AppendLine("        return this;");
        codeBuilder.AppendLine("    }");
    }

    private void AddWithPropertySetterToCodeBuilder(
        StringBuilder codeBuilder,
        ITypeSymbol typeSymbol,
        IPropertySymbol property,
        char entityNameChar
    )
    {
        MarkObsoleteAsObsolete(codeBuilder, property);

        codeBuilder.AppendLine(
            $"    public {typeSymbol.Name} With{property.Name}(Func<Bogus.Faker, {property.Type}> {property.Name}Setter)"
        );
        codeBuilder.AppendLine("    {");

        codeBuilder.AppendLine(
            $"        Faker.RuleFor({entityNameChar} => {entityNameChar}.{property.Name}, {property.Name}Setter);"
        );
        codeBuilder.AppendLine("        return this;");
        codeBuilder.AppendLine("    }");
    }

    private void MarkObsoleteAsObsolete(StringBuilder codeBuilder, IPropertySymbol property)
    {
        // Mark obsolete attributes as obsolete
        if (property.GetAttributes().Any(attr => attr.AttributeClass?.Name == "ObsoleteAttribute"))
        {
            codeBuilder.AppendLine("    [Obsolete]");
        }
    }
}
