using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CoffeeCard.Generators.Builder;

[Generator]
public class BuilderGenerator : IIncrementalGenerator
{
    private const string BuilderForAttribute = "CoffeeCard.Tests.Common.BuilderForAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var namedTypeSymbols = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: BuilderForAttribute,
                predicate: IsSyntaxTargetForGeneration,
                transform: GetSemanticTargetForGeneration)
            .Where(t => t is not null).Collect();

        context.RegisterSourceOutput(namedTypeSymbols, (productionContext, array) =>
        {
            foreach (var typeSymbol in array)
            {
                //Retrieve the entity it is a builder for
                var entity = (INamedTypeSymbol)typeSymbol.GetAttributes()
                    .Single(attr => attr.AttributeClass.Name == "BuilderForAttribute").ConstructorArguments[0].Value;
                var code = GenerateBuilderCode(typeSymbol, entity);
                var sourceText = SourceText.From(code, Encoding.UTF8);
                productionContext.AddSource($"{typeSymbol.Name}.g.cs", sourceText);
            }
        });
    }

    private static bool IsSyntaxTargetForGeneration(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        return syntaxNode is ClassDeclarationSyntax classDeclaration;
    }

    private static INamedTypeSymbol GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        return (INamedTypeSymbol)context.TargetSymbol;
    }

    private string GenerateBuilderCode(INamedTypeSymbol typeSymbol, ITypeSymbol entity)
    {
        var codeBuilder = new StringBuilder();

        codeBuilder.AppendLine("// <auto-generated/>");
        codeBuilder.AppendLine("using System;");
        codeBuilder.AppendLine("using CoffeeCard.Models.Entities;");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine("namespace CoffeeCard.Tests.Common.Builders;");
        codeBuilder.AppendLine();

        codeBuilder.AppendLine($"public partial class {typeSymbol.Name} : BaseBuilder<{entity.Name}>");
        codeBuilder.AppendLine("{");

        // Generate your builder methods here
        var properties = entity.GetMembers().OfType<IPropertySymbol>().Where(p => p.Kind == SymbolKind.Property);

        foreach (var property in properties)
        {
            codeBuilder.AppendLine(
                $"    public {typeSymbol.Name} With{property.Name}({property.Type} {property.Name}Value)");
            codeBuilder.AppendLine("    {");
            // Faker.RuleFor(u => u.Id, f => f.IndexGlobal)

            codeBuilder.AppendLine(
                $"        Faker.RuleFor({entity.Name[0]} => {entity.Name[0]}.{property.Name}, {property.Name}Value);");
            codeBuilder.AppendLine("        return this;");
            codeBuilder.AppendLine("    }");
            
            codeBuilder.AppendLine(
                $"    public {typeSymbol.Name} With{property.Name}(Func<Faker, {property.Type}> {property.Name}Setter)");
            codeBuilder.AppendLine("    {");

            codeBuilder.AppendLine(
                $"        Faker.RuleFor({entity.Name[0]} => {entity.Name[0]}.{property.Name}, {property.Name}Setter);");
            codeBuilder.AppendLine("        return this;");
            codeBuilder.AppendLine("    }");
        }

        codeBuilder.AppendLine("}");

        return codeBuilder.ToString();
    }
}