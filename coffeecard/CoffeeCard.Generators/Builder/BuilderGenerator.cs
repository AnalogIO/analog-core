using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CoffeeCard.Generators.Builder;

[Generator]
public class BuilderGenerator : IIncrementalGenerator
{
    private const string BuilderForAttribute = "CoffeeCard.Tests.Common.BuilderForAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var namedTypeSymbols = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: BuilderForAttribute,
                predicate: IsSyntaxTargetForGeneration,
                transform: GetSemanticTargetForGeneration)
            .Where(t => t is not null).Collect();

        context.RegisterSourceOutput(namedTypeSymbols, (productionContext, array) =>
        {
            foreach (var typeSymbol in array)
            {
                //Retrieve the entity it is a builder for
                var entity = (INamedTypeSymbol)typeSymbol.GetAttributes()
                    .Single(attr => attr.AttributeClass.Name == "BuilderForAttribute").ConstructorArguments[0].Value;
                var code = GenerateBuilderCode(typeSymbol, entity);
                var sourceText = SourceText.From(code, Encoding.UTF8);
                productionContext.AddSource($"{typeSymbol.Name}.g.cs", sourceText);
            }
        });
    }

    private static bool IsSyntaxTargetForGeneration(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        return syntaxNode is ClassDeclarationSyntax classDeclaration;
    }

    private static INamedTypeSymbol GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        return (INamedTypeSymbol)context.TargetSymbol;
    }

    private string GenerateBuilderCode(INamedTypeSymbol typeSymbol, ITypeSymbol entity)
    {
        var codeBuilder = new StringBuilder();

        codeBuilder.AppendLine("// <auto-generated/>");
        codeBuilder.AppendLine("using System;");
        codeBuilder.AppendLine("using Bogus;");
        codeBuilder.AppendLine($"using {entity.ContainingNamespace};");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine($"namespace {typeSymbol.ContainingNamespace};");
        codeBuilder.AppendLine();

        codeBuilder.AppendLine($"public partial class {typeSymbol.Name} : BaseBuilder<{entity.Name}>, IBuilder<{typeSymbol.Name}>");
        codeBuilder.AppendLine("{");

        // Retrieve all properties of the given entity
        var properties = entity.GetMembers().OfType<IPropertySymbol>().Where(p => p.Kind == SymbolKind.Property);

        var entityNameChar = entity.Name.ToLowerInvariant()[0];
        // Generate builder methods for all properties
        var configBuilder = new StringBuilder();
        foreach (var property in properties)
        {
            if (property.Name.Contains("Id"))
            {
                configBuilder.AppendLine($"            .Ignore({entity.Name} => {entity.Name}.{property.Name})");
            }
            AddWithPropertyValueToCodeBuilder(codeBuilder: codeBuilder,
                    typeSymbol: typeSymbol,
                    property: property,
                    entityNameChar: entityNameChar);

            AddWithPropertySetterToCodeBuilder(
                codeBuilder: codeBuilder,
                typeSymbol: typeSymbol,
                property: property,
                entityNameChar: entityNameChar);
        }
        AddPrivateConstructorToCodeBuilder(codeBuilder, typeSymbol, configBuilder);

        // End class
        codeBuilder.AppendLine("}");

        return codeBuilder.ToString();
    }

    /// <summary>
    /// Generates a private constructor for the builder, to ensure the simple, or typical methods are used for instantiation
    /// </summary>
    /// <param name="codeBuilder"></param>
    /// <param name="typeSymbol"></param>
    /// <param name="configBuilder"></param>
    private void AddPrivateConstructorToCodeBuilder(StringBuilder codeBuilder, ITypeSymbol typeSymbol, StringBuilder configBuilder)
    {
        codeBuilder.AppendLine(
            $"    private {typeSymbol.Name} ()");
        codeBuilder.AppendLine("    {");
        codeBuilder.Append("        Faker");
        codeBuilder.Append($"{configBuilder};");
        codeBuilder.AppendLine("    }");
    }

    private void AddWithPropertyValueToCodeBuilder(StringBuilder codeBuilder, ITypeSymbol typeSymbol, IPropertySymbol property, char entityNameChar)
    {
        MarkObsoleteAsObsolete(codeBuilder, property);

        codeBuilder.AppendLine(
            $"    public {typeSymbol.Name} With{property.Name}({property.Type} {property.Name}Value)");
        codeBuilder.AppendLine("    {");

        codeBuilder.AppendLine(
            $"        Faker.RuleFor({entityNameChar} => {entityNameChar}.{property.Name}, {property.Name}Value);");
        codeBuilder.AppendLine("        return this;");
        codeBuilder.AppendLine("    }");
    }
    private void AddWithPropertySetterToCodeBuilder(StringBuilder codeBuilder, ITypeSymbol typeSymbol, IPropertySymbol property, char entityNameChar)
    {
        MarkObsoleteAsObsolete(codeBuilder, property);

        codeBuilder.AppendLine(
            $"    public {typeSymbol.Name} With{property.Name}(Func<Bogus.Faker, {property.Type}> {property.Name}Setter)");
        codeBuilder.AppendLine("    {");

        codeBuilder.AppendLine(
            $"        Faker.RuleFor({entityNameChar} => {entityNameChar}.{property.Name}, {property.Name}Setter);");
        codeBuilder.AppendLine("        return this;");
        codeBuilder.AppendLine("    }");
    }

    private void MarkObsoleteAsObsolete(StringBuilder codeBuilder, IPropertySymbol property)
    {
        // Mark obsolete attributes as obsolete
        if (property.GetAttributes().Any(attr => attr.AttributeClass?.Name == "ObsoleteAttribute"))
        {
            codeBuilder.AppendLine("    [Obsolete]");
        }
    }
}